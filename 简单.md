# 1 、两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]



链接：https://leetcode-cn.com/problems/two-sum



## 题目解析

使用查找表来解决该问题。

设置一个 map 容器 record 用来记录元素的值与索引，然后遍历数组 nums。

每次遍历时使用临时变量 complement 用来保存目标值与当前值的差值。
在此次遍历中查找 record，查看是否有与 complement 一致的值，如果查找成功则返回查找值的索引值与当前变量的值 i。
如果未找到，则在 record 保存该元素与索引值 i。



## Go

```go
func twoSum(nums []int, target int) []int {
	hashmap := make(map[int]int)
	for index , num := range nums{
		if w, ok := hashmap[num];ok{
			return []int{w,index}
		} else {
			hashmap[target - num] = index
		}
	}
	return nil
}
```

## Python

```python
class Solution:
    def twoSum(self, nums, target):
        hashmap = {}
        for index , num in enumerate(nums):
            w = hashmap.get(num,None)
            if w != None:
                return [w,index]
            else:
                hashmap[target - num] = index
        return []
```



# 7 整数反转

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:

输入: 123
输出: 321
 示例 2:

输入: -123
输出: -321
示例 3:

输入: 120
输出: 21
注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

链接：https://leetcode-cn.com/problems/reverse-integer

## Python

```python
class Solution:
    def reverse(self, x: int) -> int:
        result_limit = 2 ** 31
        
        if -10 < x < 10:
            return x
        
        if len(str(abs(x))) > len(str(abs(result_limit))):
            return 0
        
        if x < 0 :
            x = -int(''.join(list(str(abs(x))[::-1])))
        else:
            x = int(''.join(list(str(abs(x))[::-1])))
        
        if -result_limit < x < result_limit:
            return x
        return 0
```

```Python
class Solution:
    def reverse(self, x: int) -> int:
        result_limit = 2 ** 31
        num = 0
        abs_x = abs(x)
        while abs_x != 0:
            num = num * 10 + abs_x % 10
            abs_x = abs_x // 10
        if num >= result_limit or num <= -result_limit:
            return 0
        return num if x > 0 else -num
```



## Go

```go
func reverse(x int) (num int){
    for x!= 0 {
        num = num * 10 + x % 10
        x = x /10
    }
    if num > math.MaxInt32 || num < math.MinInt32{
        return 0
    }
    return 
}
```

# 9 回文数

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例 1:

输入: 121
输出: true
示例 2:

输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3:

输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
进阶:

你能不将整数转为字符串来解决这个问题吗？
链接：https://leetcode-cn.com/problems/palindrome-number



## Python

```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x<0:
            return False
        
        return str(x)[::-1] == str(x)
```



## Go

```go
func isPalindrome(x int) bool {
    if x < 0 {
        return false
    }
    tmp := 0
    tmp_x := x
    for tmp_x!= 0{
        tmp = tmp * 10 + tmp_x % 10
        tmp_x = tmp_x / 10
    }
    return tmp == x
}
```

# 14 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

示例 1:

输入: ["flower","flow","flight"]
输出: "fl"
示例 2:

输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
说明:

所有输入只包含小写字母 a-z 。
链接：https://leetcode-cn.com/problems/longest-common-prefix

## Python

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        a=min(strs)
        b=max(strs)
        for index , v in enumerate(a):
            if v != b[index]:
                return a[:index]
        return a
```

# Go

```go
func longestCommonPrefix(strs []string) string {
   var s string
   tag := shortest(strs)
   if tag == "" {
       return ""
   }
   for i:=0;i<len(tag);i++{
       s = tag[0:len(tag) - i]
       for _, str := range strs {
           if s != str[0:len(s)]{
               s = ""
               break
           }
       }
       if s != ""{
           return s
       }
   }
   return s
}

func shortest(strs []string) string {
    s := ""
    for _, str := range strs {
        if str == "" {
            return ""
        }
        if s == "" || len(str) < len(s) {
            s = str
        }
    }
    return s
}
```









